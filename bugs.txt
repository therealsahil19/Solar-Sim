EASY

Description
Math.pow(a, 1.5) is called every frame for every object to calculate the orbital period if not provided.

Location
src/physics.ts:61

Rationale
High impact as it runs per object/frame. Easy fix by pre-calculating period in initialization or caching it.

Code context
    // Optimization: Use pre-calculated period if available to avoid expensive Math.pow(a, 1.5)
    const period = orbit.period ?? Math.pow(a, 1.5);

Description
Intermediate _tempVec.set(...) call is unnecessary; can write directly to buffer.

Location
src/trails.ts:279

Rationale
Micro-optimization to remove a function call and property access inside a loop.

Code context
            // Direct matrix access (approx 1.8x faster than setFromMatrixPosition)
            const te = trail.target.matrixWorld.elements;
            this._tempVec.set(te[12]!, te[13]!, te[14]!);

Description
item.name.toLowerCase() is called for every item during search filtering.

Location
src/components/CommandPalette.ts:286

Rationale
Creates garbage and CPU overhead. Should pre-calculate lowercase strings on item creation.

Code context
        } else {
            this.filteredItems = this.items.filter(item =>
                (item.name?.toLowerCase() ?? '').includes(q) ||
                (item.type?.toLowerCase() ?? '').includes(q)
            );

Description
Math.cos and Math.sin are called every frame on constant orbital elements (Omega, i).

Location
src/physics.ts:106

Rationale
Trig functions are expensive. These values are constant for each object and should be pre-calculated.

Code context
    // Longitude of Ascending Node (Omega) - use value from orbit params
    const Omega = LAN;

    const cosOm = Math.cos(Omega * DEG_TO_RAD);

Description
toLowerCase() is called O(N log N) times during sort.

Location
src/components/CommandPalette.ts:293

Rationale
Very inefficient for sorting. Pre-calculate lowercase strings.

Code context
        // Sort: Exact matches first
        this.filteredItems.sort((a, b) => {
            const aName = (a.name ?? '').toLowerCase();
            const bName = (b.name ?? '').toLowerCase();

Description
The script reads the entire response body into memory without checking the Content-Length header, which could lead to memory exhaustion (DoS) if the remote server serves a very large file.

Location
download_textures.py:52

Rationale
The script uses response.read() which loads the full content into RAM. Reading in chunks or checking the size header would mitigate this risk.

Code context
    try:
        # Verify SSL certificates properly using reused context
        with urllib.request.urlopen(url, context=context, timeout=10) as response:
            content = response.read()
            
            # Verify SHA-256
            actual_hash = hashlib.sha256(content).hexdigest()
            if actual_hash != expected_hash:

Description
The `clearMaterialCache` function is crucial for preventing memory leaks during scene resets but is currently untested.

Location
src/procedural.ts:69

Rationale
Simple to test: populate cache by requesting a material, call clear, and verify disposal and cache emptiness.

Code context
/**
 * Clears the material cache to prevent memory leaks during scene resets.
 */
export function clearMaterialCache(): void {
    Object.values(materialCache).forEach(mat => mat.dispose());
    for (const key in materialCache) delete materialCache[key];

    Object.values(textureMaterialCache).forEach(mat => mat.dispose());

Description
The `dispose` method in `InstanceRegistry` is responsible for cleaning up heavy GPU resources but is not tested.

Location
src/instancing.ts:237

Rationale
Standard resource cleanup test. Add instances, call dispose, verify scene removal and geometry/material disposal.

Code context
    /**
     * Disposes the registry and cleans up resources.
     */
    dispose(): void {
        this.groups.forEach((group) => {
            if (group.mesh) {
                this.scene.remove(group.mesh);
                group.mesh.geometry?.dispose();

Description
The orbital position solver uses a fixed iteration count which may lose accuracy for highly elliptical orbits (e > 0.9).

Location
src/physics.ts:66

Rationale
Pure function with deterministic output. Easy to construct a test case with high eccentricity and verify Kepler equation satisfaction.

Code context
    // 2. Solve Kepler's Equation for Eccentric Anomaly (E)
    // M = E - e * sin(E). Using Newton-Raphson for fast, accurate convergence.
    let E = M + e * Math.sin(M);

    for (let j = 0; j < 5; j++) {
        const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
        E = E - dE;
        if (Math.abs(dE) < 1e-12) break; // Converged to high precision
    }


MEDIUM

Description
Deeply nested logic (> 5 levels).

Location
src/components/NavigationSidebar.ts:319

Rationale
Deep nesting increases cognitive load.

Code context
if (parent.classList.contains('nav-sublist')) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:284

Rationale
Deep nesting increases cognitive load.

Code context
for (const other of cell) {

Description
Function "runCollisionDetection" is 82 lines long.

Location
src/managers/LabelManager.ts:242

Rationale
Long functions are harder to read and maintain.

Code context
    private runCollisionDetection(viewportWidth: number, viewportHeight: number): void {

Description
Function "constructor" is 110 lines long.

Location
src/trails.ts:71

Rationale
Long functions are harder to read and maintain.

Code context
    constructor(scene: THREE.Scene, maxTrails: number = 5000, pointsPerTrail: number = 100) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:316

Rationale
Deep nesting increases cognitive load.

Code context
if (cell) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:312

Rationale
Deep nesting increases cognitive load.

Code context
for (let c = startCol; c <= endCol; c++) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:281

Rationale
Deep nesting increases cognitive load.

Code context
if (idx !== -1) {

Description
Function "bindEvents" is 118 lines long.

Location
src/components/SettingsPanel.ts:144

Rationale
Long functions are harder to read and maintain.

Code context
    private bindEvents(): void {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:215

Rationale
Deep nesting increases cognitive load.

Code context
if (Math.abs(lastOpacity - opacity) > this.opacityUpdateThreshold) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:292

Rationale
Deep nesting increases cognitive load.

Code context
if (isBlocked) break;

Description
Function "startBenchmark" is 89 lines long.

Location
src/benchmark.ts:38

Rationale
Long functions are harder to read and maintain.

Code context
export function startBenchmark(durationMs: number = 5000): BenchmarkHandle {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/SettingsManager.ts:100

Rationale
Deep nesting increases cognitive load.

Code context
if (typeof parsed[key] === expectedType) {

Description
Function "init" is 108 lines long.

Location
src/main.ts:265

Rationale
Long functions are harder to read and maintain.

Code context
export async function init(): Promise<void> {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:283

Rationale
Deep nesting increases cognitive load.

Code context
if (cell) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:314

Rationale
Deep nesting increases cognitive load.

Code context
if (idx !== -1) {

Description
Deeply nested logic (> 5 levels).

Location
src/components/NavigationSidebar.ts:322

Rationale
Deep nesting increases cognitive load.

Code context
if (parentLi) parentLi.style.display = '';

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:192

Rationale
Deep nesting increases cognitive load.

Code context
if (!item) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/LabelManager.ts:285

Rationale
Deep nesting increases cognitive load.

Code context
if (this.checkOverlap(item, other)) {

Description
Deeply nested logic (> 5 levels).

Location
src/managers/SettingsManager.ts:98

Rationale
Deep nesting increases cognitive load.

Code context
if (key in parsed) {

Description
Function "createDebrisSystem" is 109 lines long.

Location
src/debris.ts:230

Rationale
Long functions are harder to read and maintain.

Code context
function createDebrisSystem(config: DebrisConfig): DebrisMesh {

HARD
Description
The spatial hashing collision detection for labels is complex and critical for mobile views but is untested.

Location
src/managers/LabelManager.ts:239

Rationale
Logic is private and coupled to viewport size and camera projection, requiring complex mocking or accessing private members.

Code context
    /**
     * Resolves label overlaps using a spatial grid.
     */
    private runCollisionDetection(viewportWidth: number, viewportHeight: number): void {
        // Sort by Z-depth (front-to-back: Painter's algorithm in reverse for labels)
        this.visibleLabelsList.sort((a, b) => a.z - b.z);

        const cellWidth = this.approxLabelWidth;
